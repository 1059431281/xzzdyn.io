(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{439:function(t,e,s){"use strict";s.r(e);var i=s(15),l=Object(i.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("       通过度娘，我们不能得知解决浮动带来的影响方法有常见的overflow:hidden和clear:both，又或是根据BFC规则解决，而今天我要讲解的关于伪元素中使用clear:both的原理（别觉得没必要，知道总比不知道好，看一看花不了几分钟的）\n"),s("br")]),s("h1",[t._v("Clear:both清除浮动原理")]),t._v("\n下面我将其分为三种状况来讲："),s("p"),t._v(" "),s("ol",[s("li",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/1059431281/Blog-source/img/md_assets/clear_both_1.png",alt:""}}),t._v('\n其中黑色部分为父元素div，红为左浮动的子div，蓝则为给父元素div添加的伪元素，此时他的内容是":after伪元素"\n在这里能明显看见，因为子元素浮动无法撑开盒子，所以我们这时给伪元素加上clear:both属性')]),t._v(" "),s("li",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/1059431281/Blog-source/img/md_assets/clear_both_2.png",alt:""}}),t._v("\nclear属性的作用是清除浮动对自己带来的影响，也就是对现在的蓝div来说红div并非处于浮动状态，自然而然它就会被挤到红色的div下面，从而导致黑div被蓝div撑开")]),t._v(" "),s("li",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/1059431281/Blog-source/img/md_assets/clear_both_3.png",alt:""}}),t._v("\n最后，只要把蓝div的内容设为空就行了（虽然没内容但还是会被挤下去，黑依旧会被撑开，而因为蓝没内容也不会被额外撑开）。还有，若要更优化可以加上visibility:hidden,使蓝div彻底不可见")])]),t._v(" "),s("p",[t._v("PS：可能存在一些看似废话的话，但这里尽可能详细，让任何人都看得懂（高手也不会来这种地方吧）")])])}),[],!1,null,null,null);e.default=l.exports}}]);